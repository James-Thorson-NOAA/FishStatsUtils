% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_model}
\alias{fit_model}
\title{Fit VAST to data}
\usage{
fit_model(
  settings,
  Lat_i,
  Lon_i,
  t_i,
  b_i,
  a_i,
  c_iz = rep(0, length(b_i)),
  v_i = rep(0, length(b_i)),
  working_dir = paste0(getwd(), "/"),
  X1config_cp = NULL,
  X2config_cp = NULL,
  covariate_data,
  X1_formula = ~0,
  X2_formula = ~0,
  Q1config_k = NULL,
  Q2config_k = NULL,
  catchability_data,
  Q1_formula = ~0,
  Q2_formula = ~0,
  newtonsteps = 1,
  silent = TRUE,
  build_model = TRUE,
  run_model = TRUE,
  test_fit = TRUE,
  ...
)
}
\arguments{
\item{settings}{Output from \code{\link{make_settings}}}

\item{Lat_i}{Latitude for each sample}

\item{Lon_i}{Longitude for each sample}

\item{t_i}{Time for each observation i}

\item{b_i}{Sampled value (biomass, counts, etc.) for each observation i}

\item{a_i}{Sampled area for each observation i;  use \code{a_i=1} for observations without a natural area measurement, while
noting that resulting densities no longer have interpretable units in that case)}

\item{c_iz}{Category (e.g., species, length-bin) for each observation i}

\item{v_i}{sampling category (e.g., vessel or tow) associated with overdispersed variation for each observation i
(by default \code{v_i=0} for all samples, which will not affect things given the default values for \code{OverdispersionConfig})}

\item{X1config_cp}{matrix of settings for each density covariate for the 1st lienar predictor,
       where the row corresponds to model category, and column corresponds to each density covariate
\describe{
  \item{X1config_cp[c,p]=0}{\code{X_ip[,p]} has no effect on the 1st linear predictor for category c}
  \item{X1config_cp[c,p]=1}{\code{X_ip[,p]} has a linear effect on 1st linear predictor for category c}
  \item{X1config_cp[c,p]=2}{\code{X_ip[,p]} has a spatially varying, zero-centered linear effect on 1st linear predictor for category c}
  \item{X1config_cp[c,p]=3}{\code{X_ip[,p]} has a spatially varying linear effect on 1st linear predictor for category c}
  \item{X1config_cp[c,p]=-1}{\code{X1config_cp[c,p]=-1} is the same as \code{X1config_cp[c,p]=2}, but without including the log-likelihood term; this is useful in special cases when carefully mirroring spatially varying coefficients, e.g., to use cohort effects in a age-structured spatio-temporal model}
}}

\item{X2config_cp}{Same as argument \code{X1config_cp} but for 2nd linear predictor}

\item{covariate_data}{data frame of covariate values with columns \code{Lat}, \code{Lon}, and \code{Year}, and other columns matching names in \code{formula}; \code{Year=NA} can be used for covariates that do not change among years (e.g., depth)}

\item{X1_formula}{right-sided formula affecting the 1st linear predictor for density, e.g.,
\code{X1_formula=~BOT_DEPTH+BOT_DEPTH^2} for a quadratic effect of variable \code{BOT_DEPTH}}

\item{X2_formula}{same as \code{X1_formula} but affecting the 2nd linear predictor for density}

\item{Q1config_k}{Same as argument \code{X1config_cp} but affecting affecting the 1st linear predictor for catchability,
and note that it is a vector (instead of matrix) given the more flexible form for catchability covariates}

\item{Q2config_k}{Same as argument \code{Q1config_cp} but affecting affecting the 2nd linear predictor for catchability}

\item{catchability_data}{data-frame of covariates for use when specifying \code{Q1_formula} and \code{Q2_formula}}

\item{Q1_formula}{same as \code{X1_formula} but affecting the 1st linear predictor for catchability (a.k.a. detectability)}

\item{Q2_formula}{same as \code{X1_formula} but affecting the 2nd linear predictor for catchability (a.k.a. detectability)}

\item{newtonsteps}{number of extra newton steps to take after optimization (alternative to \code{loopnum})}

\item{build_model}{Boolean indicating whether to build the model, \code{build_model=TRUE}, or simply build the inputs, \code{build_model=FALSE}}

\item{run_model}{Boolean indicating whether to run the model or simply return the inputs and built TMB object}

\item{test_fit}{Boolean indicating whether to apply \code{VAST::check_fit} before calculating standard errors, to test for parameters hitting bounds etc; defaults to TRUE}

\item{...}{additional arguments to pass to \code{\link{make_extrapolation_info}}, \code{\link{make_spatial_info}}, \code{\link[VAST]{make_data}}, \code{\link[VAST]{make_model}}, or \code{\link[TMBhelper]{fit_tmb}},
where arguments are matched by name against each function.  If an argument doesn't match, it is still passed to \code{\link[VAST]{make_data}}.  Note that \code{\link{make_spatial_info}}
passes named arguments to \code{\link[INLA]{inla.mesh.create}}.}
}
\value{
Object of class \code{fit_model}, containing formatted inputs and outputs from VAST
\describe{
\item{parameter_estimates}{Output from \code{\link[TMBhelper]{fit_tmb}}; see that documentation for definition of contents}
\item{extrapolation_list}{Output from \code{\link{make_extrapolation_info}}; see that documentation for definition of contents}
\item{spatial_list}{Output from \code{\link{make_spatial_info}}; see that documentation for definition of contents}
\item{data_list}{Output from \code{\link[VAST]{make_data}}; see that documentation for definition of contents}
\item{tmb_list}{Output from \code{\link[VAST]{make_model}}; see that documentation for definition of contents}
\item{ParHat}{Tagged list of maximum likelihood estimatesion of fixed effects and empirical Bayes estimates of random effects, following format of initial values generated by \code{\link[VAST]{make_parameters}}; see that documentation for definition of contents}
\item{Report}{Tagged list of VAST outputs. For example, estimated density for grid \code{g}, category \code{c}, and time \code{y} is available as \code{fit$Report$D_gcy[g,c,y]}; see Details section for description of indexing}
}
}
\description{
\code{fit_model} fits a spatio-temporal model to data
}
\details{
This function is the user-interface for the multiple mid-level functions that
perform separate components of a spatio-temporal analysis:
\itemize{
\item determine the extrapolation-grid \code{\link{make_extrapolation_info}},
\item define spatial objects \code{\link{make_spatial_info}},
\item build covariates from a formula interface \code{\link{make_covariates}},
\item assemble data \code{\link{make_data}},
\item build model \code{\link{make_model}},
\item estimate parameters \code{\link[TMBhelper]{fit_tmb}}, and
\item check for obvious problems with the estimates \code{\link{check_fit}}.
}
Please see reference documetation for each of those functions (e.g., \code{?make_extrapolation_info}) to see a list of arguments used by each mid-level function.

Specifically, the mid-level functions called by \code{fit_model(.)} look for arguments in the following order of precedence (from highest to lowest precedence):
\enumerate{
\item \code{fit_model(.)} prioritizes using named arguments passed directly to \code{fit_model(.)}. If arguments are passed this way, they are used instead of other options below.
\item If an argument is not passed supplied directly to \code{fit_model(.)}, then \code{fit_model(.)} looks for elements in input \code{settings}, as typically created by \code{\link{make_settings}}.
\item If an argument is not supplied via (1) or (2) above, then each mid-level function uses default values defined in those function arguments, e.g., see \code{args(make_extrapolation_info)} for defaults for function \code{make_extrapolation_info(.)}
}
Collectively, this order of precedence allows users to specify inputs for a specific project via input method (1), the package author to change defaults through changes in the settings
defined for a given purpose in \code{make_settings(.)} via input method (2), while still defaulting to package defaults via option (3).

Variables are indexed internally for locations \code{g}, categories \code{c}, and times \code{y}.
Location index \code{g} represents Longitude-Latitude \code{fit$extrapolation_list$Data_Extrap[which(fit$spatial_list$g_e==g),c('Lon','Lat')]};
Time index \code{y} represents time \code{fit$year_labels}; and
Category \code{g} corresponds to values in \code{fit$data_list$g_i}.
}
\examples{
\dontrun{
# Load packages
library(VAST)

# load data set
# see `?load_example` for list of stocks with example data
# that are installed automatically with `FishStatsUtils`.
example = load_example( data_set="EBS_pollock" )

# Make settings
settings = make_settings( n_x=50,
         Region=example$Region,
         purpose="index",
         strata.limits=example$strata.limits )

# Run model
fit = fit_model( "settings"=settings,
    "Lat_i"=example$sampling_data[,'Lat'],
    "Lon_i"=example$sampling_data[,'Lon'],
    "t_i"=example$sampling_data[,'Year'],
    "c_i"=rep(0,nrow(example$sampling_data)),
    "b_i"=example$sampling_data[,'Catch_KG'],
    "a_i"=example$sampling_data[,'AreaSwept_km2'],
    "v_i"=example$sampling_data[,'Vessel'] )

# Plot results
plot_results( settings=settings, fit=fit )
}

}
\seealso{
\code{\link[VAST]{VAST}} for general documentation, \code{\link[FishStatsUtils]{make_settings}} for generic settings, \code{\link[FishStatsUtils]{fit_model}} for model fitting, and \code{\link[FishStatsUtils]{plot_results}} for generic plots

\code{\link{summary.fit_model}} for methods to summarize output, including obtain a dataframe of estimated densities

Other wrapper functions: 
\code{\link{make_settings}()},
\code{\link{plot_results}()}
}
\concept{wrapper functions}
