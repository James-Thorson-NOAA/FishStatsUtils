
#' Plot results
#'
#' \code{plot_results} plots diagnostics, results, and indices for a given fitted model
#'
#' This function takes a fitted VAST model and generates a standard set of diagnostic and visualization plots.
#' It does this by calling a series of mid-level plotting functions; see list of functions in Value section of documentation.
#'
#' @inheritParams fit_model
#' @inheritParams plot_maps
#' @inheritParams plot_residuals
#' @inheritParams plot_range_edge
#' @inheritParams simulate_data
#'
#' @param fit Output from \code{fit_model}
#' @param check_residuals Boolean indicating whether to run or skip residual diagnostic plots (which can be slow as currently implemented)
#' @param ... additional settings to pass to \code{FishStatsUtils::plot_maps}
#'
#' @return Invisibly returns a tagged list of outputs generated by standard plots.
#' \describe{
#'   \item{dharmaRes}{Quantile residuals calculated using package DHARMa}
#'   \item{Enc_prob}{Output from \code{\link{plot_encounter_diagnostic}}; see that documentation for definition of optional arguments and contents}
#'   \item{Index}{Output from \code{\link{plot_biomass_index}}; see that documentation for definition of optional arguments and contents}
#'   \item{Proportions}{Output from \code{\link{calculate_proportion}}; see that documentation for definition of optional arguments and contents}
#'   \item{Range}{Output from \code{\link{plot_range_index}}; see that documentation for definition of optional arguments and contents}
#'   \item{Dens_xt}{Output from \code{\link{plot_maps}}; see that documentation for definition of optional arguments and contents}
#'   \item{Edge}{Output from \code{\link{plot_range_edge}}; see that documentation for definition of optional arguments and contents}
#' }
#'
#' @family wrapper functions
#' @seealso \code{?VAST} for general documentation, \code{?make_settings} for generic settings, \code{?fit_model} for model fitting, and \code{?plot_results} for generic plots
#'
#' @export
plot_results = function( fit, settings=fit$settings, plot_set=3, working_dir=paste0(getwd(),"/"),
  year_labels=fit$year_labels, years_to_plot=fit$years_to_plot, use_biascorr=TRUE, map_list,
  category_names, check_residuals=TRUE, projargs='+proj=longlat', zrange, n_samples=100,
  calculate_relative_to_average=FALSE, type=1, ... ){

  # Check for known issues
  if( is.null(fit$Report)) stop("`fit$Report` is missing, please check inputs")
  if( missing(category_names)) category_names = 1:fit$data_list$n_c

  # Make directory
  dir.create(working_dir, showWarnings=FALSE, recursive=TRUE)
  message("\n### Creating plots in directory ", working_dir )

  # plot data
  message("\n### Making plots of data availability and knots")
  plot_data_args = list(...)
  plot_data_args = combine_lists( "input"=plot_data_args, "default"=list(Extrapolation_List=fit$extrapolation_list,
    Spatial_List=fit$spatial_list, Lat_i=fit$data_frame[,'Lat_i'], Lon_i=fit$data_frame[,'Lon_i'],
    Year_i=fit$data_frame[,'t_i'], PlotDir=working_dir, Year_Set=year_labels), "args_to_use"=formalArgs(plot_data) )
  do.call( what=plot_data, args=plot_data_args )

  # PLot settings
  if( missing(map_list) ){
    message("\n### Obtaining default settings for plotting maps")
    map_list = make_map_info( "Region"=settings$Region, "spatial_list"=fit$spatial_list, "Extrapolation_List"=fit$extrapolation_list )
  }

  # Plot anisotropy
  message("\n### Making plot of anisotropy")
  plot_anisotropy( FileName=paste0(working_dir,"Aniso.png"), Report=fit$Report, TmbData=fit$data_list )

  # Plot index
  plot_biomass_index_args = list(...)
  if( !is.null(fit$parameter_estimates$SD) ){
    message("\n### Making plot of abundance index")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_biomass_index` isn't built to handle non-numeric `year_labels`")
    plot_biomass_index_args = combine_lists( "input"=plot_biomass_index_args, "default"=list(DirName=working_dir,
      TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Year_Set=year_labels,
      Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names), "args_to_use"=formalArgs(plot_biomass_index) )
    Index = do.call( what=plot_biomass_index, args=plot_biomass_index_args )
  }else{
    Index = "Not run"
    message("\n### Skipping plot of abundance index; must re-run with standard errors to plot")
  }

  # Plot comps
  if( !is.null(fit$parameter_estimates$SD) & fit$data_list$n_c>1 ){
    message("\n### Making plot of composition data")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_biomass_index` isn't built to handle non-numeric `year_labels`")
    Proportions = calculate_proportion( TmbData=fit$data_list, Index=Index, Year_Set=year_labels,
      Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names, DirName=working_dir )
    #Compositions = plot_biomass_index( DirName=working_dir, TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Year_Set=year_labels,
    #  Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names )
  }else{
    Proportions = "Not run"
    message("\n### Skipping plot of composition data; must re-run with standard errors and multiple categories to plot")
  }

  # Plot range indices
  if( !is.null(fit$parameter_estimates$SD) ){
    message("\n### Making plot of spatial indices")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_range_index` isn't built to handle non-numeric `year_labels`")
    Range = plot_range_index(Report=fit$Report, TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Znames=colnames(fit$data_list$Z_xm),
      PlotDir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names )
  }else{
    Range = "Not run"
    message("\n### Skipping plot of spatial indices; must re-run with standard errors to plot")
  }

  # Plot range edges
  if( "jointPrecision"%in%names(fit$parameter_estimates$SD) & n_samples>0 & fit$data_list$Options_list$Options['Calculate_Range']==TRUE ){
    message("\n### Making plot of range edges")
    Edge = plot_range_edge( Obj=fit$tmb_list$Obj, Sdreport=fit$parameter_estimates$SD,
      working_dir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot,
      category_names=category_names, n_samples=n_samples, quantiles=c(0.05,0.5,0.95),
      calculate_relative_to_average=calculate_relative_to_average )
  }else{
    Edge = "Not run"
    message("\n### Skipping plot of range edge; only possible if `getJointPrecision=TRUE`, `Options['Calculate_Range']=TRUE`, and `n_samples`>0")
  }

  # Plot densities
  message("\n### Making plots of spatial predictions")
  # Including Report as input to plot_maps_args so that it doesn't need to re-run it when loading results without TMB linked
  # Not restricting to named arguments using args_to_use so that ... passes settings to plot_variable even that aren't formal arguments to plot_maps
  plot_maps_args = list(...)
  plot_maps_args = combine_lists( "input"=plot_maps_args, "default"=list(plot_set=plot_set, category_names=category_names, TmbData=fit$data_list,
    Report=fit$Report, Sdreport=fit$parameter_estimates$SD, PlotDF=map_list[["PlotDF"]], MapSizeRatio=map_list[["MapSizeRatio"]],
    working_dir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot, legend_x=map_list[["Legend"]]$x/100, legend_y=map_list[["Legend"]]$y/100,
    Obj=fit$tmb_list$Obj, projargs=projargs) ) # , "args_to_use"=formalArgs(plot_maps)
  Dens_xt = do.call( what=plot_maps, args=plot_maps_args )

  # Plot quantile-quantile plot
  if( check_residuals == TRUE ){
    # Plot diagnostic for encounter probability
    #message("\n### Making plot of encounter probability")
    #Enc_prob = plot_encounter_diagnostic( Report=fit$Report, Data_Geostat=cbind("Catch_KG"=fit$data_frame[,'b_i']), DirName=working_dir)
    #
    #message("\n### Making Q-Q plot")
    #Q = plot_quantile_diagnostic( TmbData=fit$data_list, Report=fit$Report, FileName_PP="Posterior_Predictive",
    #  FileName_Phist="Posterior_Predictive-Histogram", FileName_QQ="Q-Q_plot", FileName_Qhist="Q-Q_hist", save_dir=working_dir )
    #
    ## Pearson residuals
    #message("\n### Making plot of Pearson residuals")
    #plot_residuals(Lat_i=fit$data_frame[,'Lat_i'], Lon_i=fit$data_frame[,'Lon_i'], TmbData=fit$data_list, Report=fit$Report,
    #  Q=Q, working_dir=working_dir, spatial_list=fit$spatial_list, extrapolation_list=fit$extrapolation_list,
    #  Year_Set=year_labels, Years2Include=years_to_plot, zrange=zrange,
    #  legend_x=map_list[["Legend"]]$x/100, legend_y=map_list[["Legend"]]$y/100 )

    # Plotting quantile residuals
    message("\n### Making quantile residuals using conditional simulation and package DHARMa")
    dharmaRes = summary( fit, what="residuals", working_dir=working_dir, type=type, ... )

    # Mapping quantile residuals
    message("\n### Plotting quantile residuals ")
    plot_quantile_residuals( dharmaRes=dharmaRes, fit=fit, working_dir=working_dir,
      Year_Set=year_labels, Years2Include=years_to_plot, ... )
  }else{
    #Q = "Not run"
    #message("\n### Skipping Q-Q plot")
    #message("\n### Skipping plot of Pearson residuals")
    message("\n### Skipping quantile residuals using conditional simulation and package DHARMa")
    message("\n### Skipping plot of quantile residuals ")
    dharmaRes = NULL
  }

  # return
  Return = list( "dharmaRes"=dharmaRes, "Index"=Index, "Proportions"=Proportions, "Range"=Range, "Dens_xt"=Dens_xt, "Edge"=Edge,
    "map_list"=map_list, "plot_maps_args"=plot_maps_args, "plot_biomass_index_args"=plot_biomass_index_args )
  return( invisible(Return) )
}

